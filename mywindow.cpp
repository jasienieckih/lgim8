// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

#include <chrono>
#include <thread>

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow),
    isDragging(false),
    triangleHidingMode(false),
    currentFrame(0),
    numberOfFrames(1),
    loopingMode(true)
{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    zeroCoordinates[0].setX(ui->drawFrame->x());
    zeroCoordinates[0].setY(ui->drawFrame->y());
    zeroCoordinates[1].setX(ui->drawFrame_2->x());
    zeroCoordinates[1].setY(ui->drawFrame_2->y());

    sourceImages[0] = new QImage(":res/keskesej4_600x600.jpg");
    sourceImages[1] = new QImage(":res/leopard_600x600.png");

    for (int i = 0; i < 2; ++i)
    {
        images[i] = new QImage(img_width, img_height, QImage::Format::Format_RGB32);
        points[i][0] = Point(200, 100);
        points[i][1] = Point(100, 500);
        points[i][2] = Point(500, 400);
        points[i][3] = Point(400, 100);
        triangles[i][0] = new TrianglePtr(&points[i][0], &points[i][1], &points[i][2]);
        triangles[i][1] = new TrianglePtr(&points[i][0], &points[i][2], &points[i][3]);
    }

    updateTexturing();
}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{
    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    for (int i = 0; i < 2; ++i)
    {
        p.drawImage(zeroCoordinates[i].x(), zeroCoordinates[i].y(), *images[i]);
    }
}

// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function (slot) called when the user clicks button "Draw 1" (draw1Button)
void MyWindow::on_draw1Button_clicked()
{
    update();
}

// Function (slot) called when the user clicks button "Draw 2" (draw2Button)
void MyWindow::on_draw2Button_clicked()
{
    update();
}

// Function cleaning the image (painting it in all white)
void MyWindow::img_clean()
{
    for (int h = 0; h < 2; ++h)
    {
        unsigned char *ptr;

        // 'bits()' returns a pointer to the first pixel of the image
        ptr = images[h]->bits();

        int i, j;

        // i - current row, it changes from 0 to img_height-1
        for(i = 0; i < img_height; i++)
        {
            // j - current column, it changes from 0 to img_width
            // each row has img_width pixels and 4 * img_width bytes (1 pixel = 4 bytes)
            for(j=0; j < img_width; j++)
            {
                // to obtain a white color we set each component on max value (255)
                ptr[img_width*4*i + 4*j] = 0xff; // BLUE component
                ptr[img_width*4*i + 4*j + 1] = 0xff; // GREEN component
                ptr[img_width*4*i + 4*j + 2] = 0xff; // RED component
            }
        }
    }
}

bool MyWindow::areCoordsValid(int x, int y)
{
    return x >= 0 and x < img_width and y >= 0 and y < img_height;
}

int MyWindow::bitsCoordFromXy(int x, int y)
{
    return 4 * (img_width * y + x);
}

int MyWindow::bitsCoordFromXy(int x, int y, int width)
{
    return 4 * (width * y + x);
}

void MyWindow::drawImages()
{
    for (int i = 0; i < 2; ++i)
    {
        uchar *bits = images[i]->bits();
        uchar *sourceBits;
        if (currentFrame == 0)
        {
            sourceBits = sourceImages[i]->bits();
        }
        else if (currentFrame == numberOfFrames - 1)
        {
            sourceBits = sourceImages[(1 - i) % 2]->bits();
        }
        else
        {
            sourceBits = (i == 0) ? frames[currentFrame - 1].image.bits()
                                  : frames[numberOfFrames - currentFrame - 1].image.bits();
        }
        for (int x = 0; x < img_width; ++x)
        {
            for (int y = 0; y < img_height; ++y)
            {
                int coords = bitsCoordFromXy(x, y);
                for (int component = 0; component < 3; ++component)
                {
                    bits[coords + component] = sourceBits[coords + component];
                }
            }
        }
    }
}

void MyWindow::drawLine(QImage& image, Point p0, Point p1)
{
    drawLine(image, p0.x(), p0.y(), p1.x(), p1.y());
}

void MyWindow::drawLine(QImage& image, int x0, int y0, int x1, int y1)
{
    const uchar color[3] = {0x80, 0x80, 0x80};

    uchar *ptr;
    ptr = image.bits();

    int x;
    int y;
    int pixel;

    int dx = abs(x0 - x1);
    int dy = abs(y0 - y1);

    if (dx > dy)
    {
        if (x0 == x1)
        {
            for (y = y0; y <= y1; ++y)
            {
                x = x0;
                pixel = img_width * 4 * y + 4 * x;
                for (int component = 0; component < 3; ++component)
                {
                    ptr[pixel + component] = color[component];
                }
            }
        }
        else
        {
            if (x0 > x1)
            {
                std::swap(x0, x1);
                std::swap(y0, y1);
            }
            double a = double(y1 - y0)/double(x1 - x0);
            double b = y0 - a * x0;

            for (x = x0; x <= x1; ++x)
            {
                y = int(round(a * x + b));
                pixel = img_width * 4 * y + 4 * x;
                for (int component = 0; component < 3; ++component)
                {
                    ptr[pixel + component] = color[component];
                }
            }
        }
    }
    else
    {
        if (y0 == y1)
        {
            for (x = x0; x <= x1; ++x)
            {
                y = y0;
                pixel = img_width * 4 * x + 4 * y;
                for (int component = 0; component < 3; ++component)
                {
                    ptr[pixel + component] = color[component];
                }
            }
        }
        else
        {
            if (y0 > y1)
            {
                std::swap(x0, x1);
                std::swap(y0, y1);
            }
            double a = double(x1 - x0)/double(y1 - y0);
            double b = x0 - a * y0;

            for (y = y0; y <= y1; ++y)
            {
                x = int(round(a * y + b));
                pixel = img_width * 4 * y + 4 * x;
                for (int component = 0; component < 3; ++component)
                {
                    ptr[pixel + component] = color[component];
                }
            }
        }
    }
}

void MyWindow::drawTriangles()
{
    for (int i = 0; i < 2; ++i)
    {
        for (int t = 0; t < NUMBER_OF_TRIANGLES; ++t)
        {
            QImage& image = *images[i];
            TrianglePtr* triangle;
            if (currentFrame == 0)
            {
                triangle = triangles[i][t];
            }
            else if (currentFrame == numberOfFrames - 1)
            {
                triangle = triangles[(1 - i) % 2][t];
            }
            else
            {
                triangle = (i == 0) ? frames[currentFrame - 1].triangles[t]
                                    : frames[numberOfFrames - currentFrame - 1].triangles[t];
            }
            drawLine(image, triangle->point(0), triangle->point(1));
            drawLine(image, triangle->point(1), triangle->point(2));
            drawLine(image, triangle->point(2), triangle->point(0));
        }
    }
}

void MyWindow::drawTriangleHandles()
{
    const uchar HANDLE_COLORS[2][3][3] = {{{0x10, 0xc8, 0x10},
                                           {0x10, 0xc8, 0x10},
                                           {0x10, 0xc8, 0x10}},
                                          {{0x10, 0xc8, 0x10},
                                           {0x10, 0xc8, 0x10},
                                           {0x10, 0xc8, 0x10}}};

    uchar* bits[2];
    for (int image = 0; image < 2; ++image)
    {
        bits[image] = images[image]->bits();
        for (int triangle = 0; triangle < NUMBER_OF_TRIANGLES; ++triangle)
        {
            TrianglePtr* trianglePtr;
            if (currentFrame == 0)
            {
                trianglePtr = triangles[image][triangle];
            }
            else if (currentFrame == numberOfFrames - 1)
            {
                trianglePtr = triangles[(1 - image) % 2][triangle];
            }
            else
            {
                trianglePtr = (image == 0) ? frames[currentFrame - 1].triangles[triangle]
                                           : frames[numberOfFrames - currentFrame - 1].triangles[triangle];
            }
            for (int point = 0; point < 3; ++point)
            {
                for (int x = trianglePtr->point(point).x() - HANDLE_RADIUS;
                     x < trianglePtr->point(point).x() + HANDLE_RADIUS; ++x)
                {
                    for (int y = trianglePtr->point(point).y() - HANDLE_RADIUS;
                         y < trianglePtr->point(point).y() + HANDLE_RADIUS; ++y)
                    {
                        if (areCoordsValid(x, y))
                        {
                            int coords = bitsCoordFromXy(x, y);
                            for (int component = 0; component < 3; ++component)
                            {
                                bits[image][coords + component] = HANDLE_COLORS[image][point][component];
                            }
                        }
                    }
                }
            }
        }
    }
}

void MyWindow::updateTexturing()
{
    img_clean();

    drawImages();
    if (not triangleHidingMode)
    {
        drawTriangles();
        drawTriangleHandles();
    }

    update();
}

void MyWindow::generateAnimation()
{
    numberOfFrames = ui->stepsSpinBox->value();
    frames = new Frame[numberOfFrames - 1];
    for (int frame = 0; frame < numberOfFrames - 1; ++frame)
    {
        // calculate the interpolation factor
        //     it should be 1 / numberOfFrames for frame = 0 (first frame,
        //     while zeroth frame is the original image interface)
        //     and 1.0 for the last frame
        double factor = (frame + 1.0) / (numberOfFrames - 1);

        // calculate point values for the frame
        for (int point = 0; point < NUMBER_OF_POINTS; ++point)
        {
            Point interpolatedPoint = points[0][point] * (1 - factor) + points[1][point] * factor;
            frames[frame].points[point] = interpolatedPoint;
        }

        // update triangles for the frame
        for (int triangle = 0; triangle < NUMBER_OF_TRIANGLES; ++triangle)
        {
            Point oa = frames[frame].triangles[triangle]->point(0);
            Point ob = frames[frame].triangles[triangle]->point(1);
            Point oc = frames[frame].triangles[triangle]->point(2);

            Point ia[2], ib[2], ic[2];
            for (int side = 0; side < 2; ++side)
            {
                ia[side] = triangles[side][triangle]->point(0);
                ib[side] = triangles[side][triangle]->point(1);
                ic[side] = triangles[side][triangle]->point(2);
            }

            uchar* inputBits[2];
            inputBits[0] = sourceImages[0]->bits();
            inputBits[1] = sourceImages[1]->bits();
            uchar* outputBits = frames[frame].image.bits();

            for (int x = 0; x < img_width; ++x)
            {
                for (int y = 0; y < img_height; ++y)
                {
                    // calculating input coordinates to source from through barycentrics
                    double coeffs[3][2];
                    for (int i = 0; i < 2; ++i)
                    {
                        double ai = oa.coord(i);
                        coeffs[0][i] = (i == 0 ? x : y) - ai;
                        coeffs[1][i] = oc.coord(i) - ai;
                        coeffs[2][i] = ob.coord(i) - ai;
                    }
                    double denominator = coeffs[2][0] * coeffs[1][1] - coeffs[1][0] * coeffs[2][1];
                    double v = (coeffs[0][0] * coeffs[1][1] - coeffs[1][0] * coeffs[0][1]) / denominator;
                    double w = (coeffs[2][0] * coeffs[0][1] - coeffs[0][0] * coeffs[2][1]) / denominator;
                    double u = 1 - v - w;
                    if (not (u < 0.0 or u > 1.0 or v < 0.0 or v > 1.0 or w < 0.0 or w > 1.0))
                    {
                        Point inputCoords[2];
                        for (int side = 0; side < 2; ++side)
                        {
                            inputCoords[side] = ia[side] * u + ib[side] * v + ic[side] * w;
                        }
                        int floors[2][2];
                        for (int side = 0; side < 2; ++side)
                        {
                            for (int dim = 0; dim < 2; ++dim)
                            {
                                floors[side][dim] = floor((dim == 0) ? inputCoords[side].x() : inputCoords[side].y());
                            }
                        }
                        if (        areCoordsValid(inputCoords[0].x(), inputCoords[0].y())
                                and areCoordsValid(inputCoords[1].x(), inputCoords[1].y())
                                and areCoordsValid(x,               y              ))
                        {
                            int bitsCoords[2][2][2];
                            for (int side = 0; side < 2; ++side)
                            {
                                for (int x = 0; x < 2; ++x)
                                {
                                    for (int y = 0; y < 2; ++y)
                                    {
                                        bitsCoords[side][y][x] = bitsCoordFromXy(floors[side][0] + x, floors[side][1] + y);
                                    }
                                }
                            }
                            // bilinear interpolation of color
                            int outputBitsCoords = bitsCoordFromXy(x, y);
                            for (int component = 0; component < 3; ++component)
                            {
                                double neighbours[2][2][2];
                                for (int side = 0; side < 2; ++side)
                                {
                                    for (int i = 0; i < 2; ++i)
                                    {
                                        for (int j = 0; j < 2; ++j)
                                        {
                                            neighbours[side][i][j]
                                                    = inputBits[side][bitsCoords[side][i][j] + component] * (1 - factor)
                                                    + inputBits[side][bitsCoords[side][i][j] + component] * factor;
                                        }
                                    }
                                }
                                double interpolated[2][2];
                                double factors[2];
                                for (int side = 0; side < 2; ++side)
                                {
                                    factors[side] = inputCoords[side].x() - floor(inputCoords[side].x());
                                }
                                double interpolatedFactor = (1 - factor) * factors[0] + factor * factors[1];
                                for (int side = 0; side < 2; ++side)
                                {
                                    for (int i = 0; i < 2; ++i)
                                    {
                                        interpolated[side][i] = (1 - interpolatedFactor) * neighbours[side][i][0]
                                                        + interpolatedFactor       * neighbours[side][i][1];
                                    }
                                }

                                for (int side = 0; side < 2; ++side)
                                {
                                    factors[side] = inputCoords[side].x() - floor(inputCoords[side].x());
                                }
                                interpolatedFactor = (1 - factor) * factors[0] + factor * factors[1];
                                double interpolatedForEachSide[2];
                                for (int side = 0; side < 2; ++side)
                                {
                                    interpolatedForEachSide[side] = (1 - interpolatedFactor) * interpolated[side][0]
                                                                  + interpolatedFactor       * interpolated[side][1];
                                }
                                double finalInterpolated = (1 - factor) * interpolatedForEachSide[0]
                                                         + factor       * interpolatedForEachSide[1];
                                outputBits[outputBitsCoords + component] = round(finalInterpolated);
                            }
                        }
                    }
                }
            }
        }

        // set progress bar
        ui->progressBar->setValue(round(100.0 * factor));
    }
}

void MyWindow::playAnimation()
{
    // 60 fps
    const double frameTimeInMilliseconds = 1.0 / 60.0 * 1000.0;
    const auto frameTime = std::chrono::milliseconds(int(round(frameTimeInMilliseconds)));

    auto startTime = std::chrono::system_clock::now();
    auto nextTime = startTime;
    for (int i = 0; i < numberOfFrames; ++i)
    {
        nextTime += frameTime;

        int frameSliderValue = int(round(i * 1000.0 / (numberOfFrames - 1)));
        ui->frameSlider->setValue(frameSliderValue);
        repaint();

        std::this_thread::sleep_until(nextTime);
    }
    if (loopingMode)
    {
        for (int i = numberOfFrames - 2; i >= 0; --i)
        {
            nextTime += frameTime;

            int frameSliderValue = int(round(i * 1000.0 / (numberOfFrames - 1)));
            ui->frameSlider->setValue(frameSliderValue);
            repaint();

            std::this_thread::sleep_until(nextTime);
        }
    }
}

void MyWindow::mousePressEvent(QMouseEvent *event)
{
    Point click = Point(event->x(), event->y());

    int image_index = (click.x() < 672) ? 0 : 1;
    click = click - zeroCoordinates[image_index];

    for (int point = 0; point < NUMBER_OF_POINTS; ++point)
    {
        Point delta = points[image_index][point] - click;
        delta = delta.getAbsolute();
        if (delta.x() <= HANDLE_RADIUS and delta.y() <= HANDLE_RADIUS)
        {
            whichPointDragged = point;
            isDragging = true;
            break;
        }
    }
}

void MyWindow::mouseReleaseEvent(QMouseEvent *event)
{
    Point click = Point(event->x(), event->y());

    int image_index = (click.x() < 672) ? 0 : 1;
    click = click - zeroCoordinates[image_index];

    if (isDragging)
    {
        isDragging = false;
        points[image_index][whichPointDragged].set(click.x(), click.y());
        updateTexturing();
    }
}

void MyWindow::on_hideCheckBox_toggled(bool checked)
{
    triangleHidingMode = checked;
    updateTexturing();
}

void MyWindow::on_animateButton_clicked()
{
    generateAnimation();
}

void MyWindow::on_frameSlider_valueChanged(int value)
{
    currentFrame = round(value / 1000.0 * (numberOfFrames - 1));
    updateTexturing();
}

void MyWindow::on_playButton_clicked()
{
    playAnimation();
}

void MyWindow::on_loopCheckBox_toggled(bool checked)
{
    loopingMode = checked;
}

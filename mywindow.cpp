// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

#include "matrix.h"

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow),
    scalingTogether(false),
    deepBlueTrianglesTexture(":res/deep_blue_triangles.png",
                         Point(1633, 6, 1), Point(6, 1905, 1), Point(2656, 1532, 1),
                         0.2, 0.15, 0.6, 1000),
    redTrianglesTexture(":res/red_triangles.png",
                         Point(1633, 6, 1), Point(6, 1905, 1), Point(2656, 1532, 1),
                         0.2, 0.15  , 0.6, 1000),
    emeraldTrianglesTexture(":res/emerald_triangles.png",
                         Point(1633, 6, 1), Point(6, 1905, 1), Point(2656, 1532, 1),
                         0.2, 0.15, 0.6, 1000),
    purpleTrianglesTexture(":res/purple_triangles.png",
                         Point(1633, 6, 1), Point(6, 1905, 1), Point(2656, 1532, 1),
                         0.2, 0.15, 0.6, 1000),
    background(":res/nebula_background.png")

{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    img_x0 = ui->drawFrame->x();
    img_y0 = ui->drawFrame->y();

    // Create an object of QImage class of appropriate width
    // and height. Set its format for 32-bit RGB (0xffRRGGBB).
    img = new QImage(img_width,img_height,QImage::Format_RGB32);


    points.emplace_back(Point( 0.000000000, -0.612372436,  0.000000000 ));
    points.emplace_back(Point( 0.000000000,  0.306186218,  0.530330056 ));
    points.emplace_back(Point( 0.459279327,  0.306186218, -0.2651650430));
    points.emplace_back(Point(-0.459279327,  0.306186218, -0.2651650430));

    polygons.emplace_back(Polygon(&points[0], &points[1], &points[2], &deepBlueTrianglesTexture));
    polygons.emplace_back(Polygon(&points[0], &points[3], &points[1], &emeraldTrianglesTexture));
    polygons.emplace_back(Polygon(&points[0], &points[2], &points[3], &purpleTrianglesTexture));
    polygons.emplace_back(Polygon(&points[1], &points[3], &points[2], &redTrianglesTexture));

    startTimer(15);

    irisPoint = Point(0.0, 0.0, -5.0);

    updateProjection();
}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

bool MyWindow::areCoordsValid(int x, int y)
{
    return x >= 0 and x < img_width and y >= 0 and y < img_height;
}

bool MyWindow::areCoordsValid(int x, int y, int width, int height)
{
    return x >= 0 and x < width and y >= 0 and y < height;
}

double min(double a, double b, double c)
{
    if (a < b)
    {
        if (a < c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b < c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

double max(double a, double b, double c)
{
    if (a > b)
    {
        if (a > c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b > c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

int MyWindow::bitsCoordFromXy(int x, int y)
{
    return 4 * (img_width * y + x);
}

int MyWindow::bitsCoordFromXy(int x, int y, int width)
{
    return 4 * (width * y + x);
}

void MyWindow::updateProjection()
{
    img_clean();

    uchar* outputBits = img->bits();

    double zBuffer[600][600];
    for (int x = 0; x < 600; ++x)
    {
        for (int y = 0; y < 600; ++y)
        {
            zBuffer[x][y] = 1000000.0;
        }
    }

    Matrix projectionMatrix;
    projectionMatrix = projectionMatrix * 300;
    projectionMatrix.set(0, 3, 300.0);
    projectionMatrix.set(1, 3, 300.0);
    projectionMatrix.set(2, 3, 300.0);

    double distance = -irisPoint.z();

    Matrix finalMatrix;
    finalMatrix = finalMatrix * translationMatrix;
    finalMatrix = finalMatrix * rotationMatrixXAxis;
    finalMatrix = finalMatrix * rotationMatrixYAxis;
    finalMatrix = finalMatrix * shearingXMatrix;
    finalMatrix = finalMatrix * shearingYMatrix;
    finalMatrix = finalMatrix * shearingZMatrix;
    finalMatrix = finalMatrix * scalingMatrix;

    for (auto polygon = polygons.begin(); polygon != polygons.end(); ++polygon)
    {
        Point originalPoints[3];
        for (int i = 0; i < 3; ++i)
        {
            originalPoints[i] = polygon->point(i);
            originalPoints[i] = finalMatrix * originalPoints[i];
        }

        Point normalVector = (originalPoints[1] - originalPoints[0])
                           ^ (originalPoints[2] - originalPoints[0]);
        normalVector = normalVector / normalVector.norm();

        Point projectedPoints[3];
        for (int i = 0; i < 3; ++i)
        {
            projectedPoints[i].setX(originalPoints[i].x() * (distance / (originalPoints[i].z() + distance)));
            projectedPoints[i].setY(originalPoints[i].y() * (distance / (originalPoints[i].z() + distance)));
            projectedPoints[i].setZ(1.0);
            projectedPoints[i] = projectionMatrix * projectedPoints[i];
        }

        int xMin = floor(min(projectedPoints[0].x(), projectedPoints[1].x(), projectedPoints[2].x()));
        int yMin = floor(min(projectedPoints[0].y(), projectedPoints[1].y(), projectedPoints[2].y()));
        int xMax =  ceil(max(projectedPoints[0].x(), projectedPoints[1].x(), projectedPoints[2].x()));
        int yMax =  ceil(max(projectedPoints[0].y(), projectedPoints[1].y(), projectedPoints[2].y()));

        for (int x = xMin; x <= xMax; ++x)
        {
            for (int y = yMin; y <= yMax; ++y)
            {
                if (areCoordsValid(x, y))
                {
                    // calculating input coordinates to source from through barycentrics
                    double coeffs[3][2];
                    for (int i = 0; i < 2; ++i)
                    {
                        double ai = projectedPoints[0].coord(i);
                        coeffs[0][i] = (i == 0 ? x : y) - ai;
                        coeffs[1][i] = projectedPoints[2].coord(i) - ai;
                        coeffs[2][i] = projectedPoints[1].coord(i) - ai;
                    }
                    double denominator = coeffs[2][0] * coeffs[1][1] - coeffs[1][0] * coeffs[2][1];
                    double v = (coeffs[0][0] * coeffs[1][1] - coeffs[1][0] * coeffs[0][1]) / denominator;
                    double w = (coeffs[2][0] * coeffs[0][1] - coeffs[0][0] * coeffs[2][1]) / denominator;
                    double u = 1 - v - w;

                    Point reflectionPoint = originalPoints[0] * u
                                          + originalPoints[1] * v
                                          + originalPoints[2] * w;
                    double reflectionPointToIrisDistance = reflectionPoint.distanceFrom(irisPoint);

                    if (reflectionPointToIrisDistance < zBuffer[x][y]
                            and not (u < 0.0 or u > 1.0
                                     or v < 0.0 or v > 1.0
                                     or w < 0.0 or w > 1.0))
                    {
                        const Texture *texture = polygon->texture();

                        Point ia = texture->point(0);
                        Point ib = texture->point(1);
                        Point ic = texture->point(2);

                        const uchar* inputBits = texture->bits();

                        Point inputCoords = ia * u + ib * v + ic * w;
                        int width = texture->width();
                        int height = texture->height();
                        if (areCoordsValid(inputCoords.x(), inputCoords.y(), width, height)
                                and areCoordsValid(x, y))
                        {
                            // lightning calculation

                            const double ambientLightning = 1.0;
                            Point lightSourcePosition = Point(0.0, -1.5, -2.5);
                            const double lightSourceIntensity = 8.0;
                            double airClearness = 0.9;

                            Point lightVector = reflectionPoint - lightSourcePosition;
                            lightVector = lightVector / lightVector.norm();
                            double lightNormalAngleCosine = normalVector * lightVector;

                            Point irisVector = irisPoint - reflectionPoint;
                            irisVector = irisVector / irisVector.norm();
                            Point reflectedLightVector = lightVector * (-1) + normalVector * ((lightVector * normalVector) * 2);
                            reflectedLightVector = reflectedLightVector / reflectedLightVector.norm();
                            double reflectedLightIrisAngleCosine = irisVector * reflectedLightVector;

                            double ambientReflectionCoeff = texture->ambientReflectionCoeff();
                            double dispersedReflectionCoeff = texture->dispersedReflectionCoeff();
                            double directReflectionCoeff = texture->directReflectionCoeff();
                            if (ui->customLightCheckBox->isChecked())
                            {
                                ambientReflectionCoeff *= ui->ambientReflectionSlider->value() / 1000.0;
                                airClearness *= ui->airClearnessSlider->value() / 1000.0;
                                dispersedReflectionCoeff *= ui->dispersedReflectionSlider->value() / 1000.0;
                                directReflectionCoeff *= ui->directReflectionSlider->value() / 1000.0;
                            }

                            double lightSourceCoeff = lightSourceIntensity * airClearness;
                            double lightningCoefficient = 0.0;
                            if (lightNormalAngleCosine > 0.0)
                                lightningCoefficient += dispersedReflectionCoeff * lightNormalAngleCosine;
                            if (reflectedLightIrisAngleCosine < 0.001)
                                lightningCoefficient += directReflectionCoeff * pow(reflectedLightIrisAngleCosine, texture->surfaceSmoothnessCoeff());
                            lightningCoefficient *= lightSourceCoeff;
                            lightningCoefficient += ambientLightning * ambientReflectionCoeff;
                            if (lightningCoefficient < 0.0)
                                lightningCoefficient = 0.0;

                            // bilinear interpolation of color

                            int bitsCoords[2][2];
                            int floorX = floor(inputCoords.x());
                            int floorY = floor(inputCoords.y());
                            bitsCoords[0][0] = bitsCoordFromXy(floorX,     floorY    , width);
                            bitsCoords[0][1] = bitsCoordFromXy(floorX + 1, floorY    , width);
                            bitsCoords[1][0] = bitsCoordFromXy(floorX,     floorY + 1, width);
                            bitsCoords[1][1] = bitsCoordFromXy(floorX + 1, floorY + 1, width);

                            int outputBitsCoords = bitsCoordFromXy(x, y);

                            for (int component = 0; component < 3; ++component)
                            {
                                double neighbours[2][2];
                                for (int i = 0; i < 2; ++i)
                                {
                                    for (int j = 0; j < 2; ++j)
                                    {
                                        if (ui->useTexturesCheckBox->isChecked())
                                            neighbours[i][j] = inputBits[bitsCoords[i][j] + component];
                                        else
                                            neighbours[i][j] = 0x77;
                                    }
                                }
                                double interpolated[2];
                                double factor = inputCoords.x() - floor(inputCoords.x());
                                for (int i = 0; i < 2; ++i)
                                {
                                    interpolated[i] = (1 - factor) * neighbours[i][0] + factor * neighbours[i][1];
                                }
                                factor = inputCoords.y() - floor(inputCoords.y());
                                double finalInterpolated = (1 - factor) * interpolated[0] + factor * interpolated[1];

                                // applying lightning
                                double finalColor = lightningCoefficient * finalInterpolated;
                                int integerColor = round(finalColor);
                                if (integerColor > 0xff)
                                    integerColor = 0xff;
                                outputBits[outputBitsCoords + component] = integerColor;
                            }
                            zBuffer[x][y] = reflectionPointToIrisDistance;
                        }
                    }
                }
            }
        }
    }

    update();
}

void MyWindow::timerEvent(QTimerEvent *event)
{
    irisPoint.setZ(irisPoint.z() + 0.05);

    updateProjection();

    event->setAccepted(true);
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{

    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    // Draws an image 'img' by copying it into the paint device.
    // (img_x0, img_y0) specifies the top-left point in the paint device that is to be drawn onto.
    p.drawImage(img_x0,img_y0,*img);
}


// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function (slot) called when the user clicks button "Draw 1" (draw1Button)
void MyWindow::on_draw1Button_clicked()
{
    update();
}

// Function (slot) called when the user clicks button "Draw 2" (draw2Button)
void MyWindow::on_draw2Button_clicked()
{
    update();
}

void MyWindow::img_clean()
{
    unsigned char *ptr, *sourcePtr;

    ptr = img->bits();
    sourcePtr = background.bits();

    for(int x = 0; x < img_height; x++)
    {
        for(int y = 0; y < img_width; y++)
        {
            int coords = bitsCoordFromXy(x, y);
            for (int component = 0; component < 3; ++component)
            {
                ptr[coords + component] = sourcePtr[coords + component];
            }
        }
    }
}

// Function (slot) called when the user press mouse button
void MyWindow::mousePressEvent(QMouseEvent *event)
{
    int x = event->x();
    int y = event->y();

    x -= img_x0;
    y -= img_y0;
}

void MyWindow::on_translationXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(0, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(1, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(2, 3, dvalue);
    updateProjection();
}

void MyWindow::on_rotationSlider1_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixXAxis.set(1, 1, cosine);
    rotationMatrixXAxis.set(1, 2, -sine);
    rotationMatrixXAxis.set(2, 1, sine);
    rotationMatrixXAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_rotationSlider2_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixYAxis.set(0, 0, cosine);
    rotationMatrixYAxis.set(0, 2, sine);
    rotationMatrixYAxis.set(2, 0, -sine);
    rotationMatrixYAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_scalingXSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(0, 0, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(1, 1, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingYSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingYSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(1, 1, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingZSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(2, 2, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(1, 1, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingYSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_shearingXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingXMatrix.set(0, 1, dvalue);
    shearingXMatrix.set(0, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingYMatrix.set(1, 0, dvalue);
    shearingYMatrix.set(1, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingZMatrix.set(2, 0, dvalue);
    shearingZMatrix.set(2, 1, dvalue);
    updateProjection();
}

void MyWindow::on_resetButton_clicked()
{
    ui->translationXSlider->setValue(1000);
    ui->translationYSlider->setValue(1000);
    ui->translationZSlider->setValue(1000);
    ui->scalingXSlider->setValue(1000);
    ui->scalingYSlider->setValue(1000);
    ui->scalingZSlider->setValue(1000);
    ui->rotationSlider1->setValue(0);
    ui->rotationSlider2->setValue(0);
    ui->shearingXSlider->setValue(1000);
    ui->shearingYSlider->setValue(1000);
    ui->shearingZSlider->setValue(1000);
    ui->ambientReflectionSlider->setValue(1000);
    ui->airClearnessSlider->setValue(1000);
    ui->dispersedReflectionSlider->setValue(1000);
    ui->directReflectionSlider->setValue(1000);
    updateProjection();
}

void MyWindow::on_scalingTogetherBox_toggled(bool checked)
{
    scalingTogether = checked;
}

void MyWindow::on_ambientReflectionSlider_valueChanged(int value)
{
    value = value;
    updateProjection();
}

void MyWindow::on_airClearnessSlider_valueChanged(int value)
{
    value = value;
    updateProjection();
}

void MyWindow::on_dispersedReflectionSlider_valueChanged(int value)
{
    value = value;
    updateProjection();
}

void MyWindow::on_directReflectionSlider_valueChanged(int value)
{
    value = value;
    updateProjection();
}

void MyWindow::on_customLightCheckBox_clicked()
{
    updateProjection();
}

void MyWindow::on_useTexturesCheckBox_clicked()
{
    updateProjection();
}

// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

#include "matrix.h"

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow),
    scalingTogether(false),
    brickTexture(":res/blue_plastic.png")
{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    img_x0 = ui->drawFrame->x();
    img_y0 = ui->drawFrame->y();

    // Create an object of QImage class of appropriate width
    // and height. Set its format for 32-bit RGB (0xffRRGGBB).
    img = new QImage(img_width,img_height,QImage::Format_RGB32);


    points.emplace_back(Point( 0.000000000, -0.612372436,  0.000000000 ));
    points.emplace_back(Point( 0.000000000,  0.306186218,  0.530330056 ));
    points.emplace_back(Point( 0.459279327,  0.306186218, -0.2651650430));
    points.emplace_back(Point(-0.459279327,  0.306186218, -0.2651650430));

    polygons.emplace_back(Polygon(&points[0], &points[1], &points[2]));
    polygons.emplace_back(Polygon(&points[0], &points[1], &points[3]));
    polygons.emplace_back(Polygon(&points[0], &points[2], &points[3]));
    polygons.emplace_back(Polygon(&points[1], &points[2], &points[3]));

    updateProjection();
}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

bool MyWindow::areCoordsValid(int x, int y)
{
    return x >= 0 and x < img_width and y >= 0 and y < img_height;
}

double min(double a, double b, double c)
{
    if (a < b)
    {
        if (a < c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b < c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

double max(double a, double b, double c)
{
    if (a > b)
    {
        if (a > c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b > c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

int MyWindow::bitsCoordFromXy(int x, int y)
{
    return 4 * (img_width * y + x);
}

int MyWindow::bitsCoordFromXy(int x, int y, int width)
{
    return 4 * (width * y + x);
}

void MyWindow::updateProjection()
{
    img_clean();

    uchar* outputBits = img->bits();

    double zBuffer[600][600];
    for (int x = 0; x < 600; ++x)
    {
        for (int y = 0; y < 600; ++y)
        {
            zBuffer[x][y] = 1000000.0;
        }
    }

    Matrix projectionMatrix;
    projectionMatrix = projectionMatrix * 300;
    projectionMatrix.set(0, 3, 300.0);
    projectionMatrix.set(1, 3, 300.0);
    projectionMatrix.set(2, 3, 300.0);

    double distance = 5.0;

    Matrix finalMatrix;
    finalMatrix = finalMatrix * translationMatrix;
    finalMatrix = finalMatrix * rotationMatrixXAxis;
    finalMatrix = finalMatrix * rotationMatrixYAxis;
    finalMatrix = finalMatrix * shearingXMatrix;
    finalMatrix = finalMatrix * shearingYMatrix;
    finalMatrix = finalMatrix * shearingZMatrix;
    finalMatrix = finalMatrix * scalingMatrix;

    for (auto polygon = polygons.begin(); polygon != polygons.end(); ++polygon)
    {
        Point originalPoints[3];
        for (int i = 0; i < 3; ++i)
        {
            originalPoints[i] = polygon->point(i);
            originalPoints[i] = finalMatrix * originalPoints[i];
        }
        Point projectedPoints[3];
        for (int i = 0; i < 3; ++i)
        {
            projectedPoints[i].setX(originalPoints[i].x() * (distance / (originalPoints[i].z() + distance)));
            projectedPoints[i].setY(originalPoints[i].y() * (distance / (originalPoints[i].z() + distance)));
            projectedPoints[i].setZ(1.0);
            projectedPoints[i] = projectionMatrix * projectedPoints[i];
        }

        Point centroid = (originalPoints[0] + originalPoints[1] + originalPoints[2]) * 0.333333333;
        double centroidToIrisDistance = centroid.distanceFrom(Point(0.0, 0.0, -distance));

        int xMin = floor(min(projectedPoints[0].x(), projectedPoints[1].x(), projectedPoints[2].x()));
        int yMin = floor(min(projectedPoints[0].y(), projectedPoints[1].y(), projectedPoints[2].y()));
        int xMax =  ceil(max(projectedPoints[0].x(), projectedPoints[1].x(), projectedPoints[2].x()));
        int yMax =  ceil(max(projectedPoints[0].y(), projectedPoints[1].y(), projectedPoints[2].y()));

        for (int x = xMin; x <= xMax; ++x)
        {
            for (int y = yMin; y <= yMax; ++y)
            {
                if (areCoordsValid(x, y) and zBuffer[x][y] > centroidToIrisDistance)
                {
                    // calculating input coordinates to source from through barycentrics
                    double coeffs[3][2];
                    for (int i = 0; i < 2; ++i)
                    {
                        double ai = projectedPoints[0].coord(i);
                        coeffs[0][i] = (i == 0 ? x : y) - ai;
                        coeffs[1][i] = projectedPoints[2].coord(i) - ai;
                        coeffs[2][i] = projectedPoints[1].coord(i) - ai;
                    }
                    double denominator = coeffs[2][0] * coeffs[1][1] - coeffs[1][0] * coeffs[2][1];
                    double v = (coeffs[0][0] * coeffs[1][1] - coeffs[1][0] * coeffs[0][1]) / denominator;
                    double w = (coeffs[2][0] * coeffs[0][1] - coeffs[0][0] * coeffs[2][1]) / denominator;
                    double u = 1 - v - w;
                    if (not (u < 0.0 or u > 1.0 or v < 0.0 or v > 1.0 or w < 0.0 or w > 1.0))
                    {
                        Point ia = brickTexture.point(0);
                        Point ib = brickTexture.point(1);
                        Point ic = brickTexture.point(2);

                        Point inputCoords = ia * u + ib * v + ic * w;
                        int floorX = floor(inputCoords.x());
                        int floorY = floor(inputCoords.y());
                        if (        areCoordsValid(inputCoords.x(), inputCoords.y())
                                and areCoordsValid(x,               y              ))
                        {
                            // lightning calculation
                            double ambientLightning = 0.5;
                            double ambientReflectionCoeff = 0.5;
                            Point lightSourcePosition = Point(0, -1.0, 2.5);
                            double lightSourceIntensity = 1.1;
                            double airClearness = 0.1;
                            double dispersedReflectionCoeff = 0.6;
                            double directReflectionCoeff = 0.75;
                            double surfaceSmoothnessCoefficient = 2;

                            // move this to polygon-wise
                            Point normalVector = (originalPoints[1] - originalPoints[0])
                                               ^ (originalPoints[2] - originalPoints[0]);

                            double lightNormalAngle = 0.5;
                            double lightEyeAngle = 0.5;

                            double lightningCoefficient = ambientLightning * ambientReflectionCoeff
                                    + lightSourceIntensity * airClearness
                                    * (  directReflectionCoeff    * cos(lightNormalAngle)
                                       + dispersedReflectionCoeff * pow(cos(lightEyeAngle), surfaceSmoothnessCoefficient));
                            // now we only need to really calculate the angles on a per-point basis
                            //      and then adjust the coefficient and perhaps move them away from here

                            // bilinear interpolation of color

                            int bitsCoords[2][2];
                            bitsCoords[0][0] = bitsCoordFromXy(floorX,     floorY    , 300);
                            bitsCoords[0][1] = bitsCoordFromXy(floorX + 1, floorY    , 300);
                            bitsCoords[1][0] = bitsCoordFromXy(floorX,     floorY + 1, 300);
                            bitsCoords[1][1] = bitsCoordFromXy(floorX + 1, floorY + 1, 300);

                            const uchar* inputBits = brickTexture.bits();

                            int outputBitsCoords = bitsCoordFromXy(x, y);

                            for (int component = 0; component < 3; ++component)
                            {
                                double neighbours[2][2];
                                for (int i = 0; i < 2; ++i)
                                {
                                    for (int j = 0; j < 2; ++j)
                                    {
                                        neighbours[i][j] = inputBits[bitsCoords[i][j] + component];
                                    }
                                }
                                double interpolated[2];
                                double factor = inputCoords.x() - floor(inputCoords.x());
                                for (int i = 0; i < 2; ++i)
                                {
                                    interpolated[i] = (1 - factor) * neighbours[i][0] + factor * neighbours[i][1];
                                }
                                factor = inputCoords.y() - floor(inputCoords.y());
                                double finalInterpolated = (1 - factor) * interpolated[0] + factor * interpolated[1];
                                double finalColor = lightningCoefficient * finalInterpolated;
                                outputBits[outputBitsCoords + component] = round(finalColor);
                            }
                            zBuffer[x][y] = centroidToIrisDistance;
                        }
                    }
                }
            }
        }
    }

    update();
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{

    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    // Draws an image 'img' by copying it into the paint device.
    // (img_x0, img_y0) specifies the top-left point in the paint device that is to be drawn onto.
    p.drawImage(img_x0,img_y0,*img);
}


// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function (slot) called when the user clicks button "Draw 1" (draw1Button)
void MyWindow::on_draw1Button_clicked()
{
    update();
}

// Function (slot) called when the user clicks button "Draw 2" (draw2Button)
void MyWindow::on_draw2Button_clicked()
{
    update();
}

// Function cleaning the image (painting it in all white)
void MyWindow::img_clean()
{
    unsigned char *ptr;

    // 'bits()' returns a pointer to the first pixel of the image
    ptr = img->bits();

    int i,j;

    // i - current row, it changes from 0 to img_height-1
    for(i=0; i<img_height; i++)
    {
        // j - current column, it changes from 0 to img_width
        // each row has img_width pixels and 4 * img_width bytes (1 pixel = 4 bytes)
        for(j=0; j<img_width; j++)
        {
            ptr[img_width*4*i + 4*j    ] = 0x00; // BLUE component
            ptr[img_width*4*i + 4*j + 1] = 0x00; // GREEN component
            ptr[img_width*4*i + 4*j + 2] = 0x00; // RED component
        }
    }
}

// Function (slot) called when the user press mouse button
void MyWindow::mousePressEvent(QMouseEvent *event)
{
    int x = event->x();
    int y = event->y();

    x -= img_x0;
    y -= img_y0;
}

void MyWindow::on_translationXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(0, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(1, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(2, 3, dvalue);
    updateProjection();
}

void MyWindow::on_rotationSlider1_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixXAxis.set(1, 1, cosine);
    rotationMatrixXAxis.set(1, 2, -sine);
    rotationMatrixXAxis.set(2, 1, sine);
    rotationMatrixXAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_rotationSlider2_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixYAxis.set(0, 0, cosine);
    rotationMatrixYAxis.set(0, 2, sine);
    rotationMatrixYAxis.set(2, 0, -sine);
    rotationMatrixYAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_scalingXSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(0, 0, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(1, 1, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingYSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingYSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(1, 1, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingZSlider_valueChanged(int value)
{
    double dvalue = value / 1000.0;
    scalingMatrix.set(2, 2, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(1, 1, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingYSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_shearingXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingXMatrix.set(0, 1, dvalue);
    shearingXMatrix.set(0, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingYMatrix.set(1, 0, dvalue);
    shearingYMatrix.set(1, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingZMatrix.set(2, 0, dvalue);
    shearingZMatrix.set(2, 1, dvalue);
    updateProjection();
}

void MyWindow::on_resetButton_clicked()
{
    ui->translationXSlider->setValue(1000);
    ui->translationYSlider->setValue(1000);
    ui->translationZSlider->setValue(1000);
    ui->scalingXSlider->setValue(1000);
    ui->scalingYSlider->setValue(1000);
    ui->scalingZSlider->setValue(1000);
    ui->rotationSlider1->setValue(0);
    ui->rotationSlider2->setValue(0);
    ui->shearingXSlider->setValue(1000);
    ui->shearingYSlider->setValue(1000);
    ui->shearingZSlider->setValue(1000);
    updateProjection();
}

void MyWindow::on_scalingTogetherBox_toggled(bool checked)
{
    scalingTogether = checked;
}

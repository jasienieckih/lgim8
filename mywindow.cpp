// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

#include "matrix.h"

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow),
    scalingTogether(false),
    brickTexture(":res/brick_wall_texture300.png")
{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    img_x0 = ui->drawFrame->x();
    img_y0 = ui->drawFrame->y();

    // Create an object of QImage class of appropriate width
    // and height. Set its format for 32-bit RGB (0xffRRGGBB).
    img = new QImage(img_width,img_height,QImage::Format_RGB32);


    points.emplace_back(Point( 0.000000000, -0.612372436,  0.000000000 ));
    points.emplace_back(Point( 0.000000000,  0.306186218,  0.530330056 ));
    points.emplace_back(Point( 0.459279327,  0.306186218, -0.2651650430));
    points.emplace_back(Point(-0.459279327,  0.306186218, -0.2651650430));

    polygons.emplace_back(Polygon(&points[0], &points[1], &points[2]));
    polygons.emplace_back(Polygon(&points[0], &points[1], &points[3]));
    polygons.emplace_back(Polygon(&points[0], &points[2], &points[3]));
    polygons.emplace_back(Polygon(&points[1], &points[2], &points[3]));

    updateProjection();
}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

bool MyWindow::areCoordsValid(int x, int y)
{
    return x >= 0 and x < img_width and y >= 0 and y < img_height;
}

double min(double a, double b, double c)
{
    if (a < b)
    {
        if (a < c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b < c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

double max(double a, double b, double c)
{
    if (a > b)
    {
        if (a > c)
        {
            return a;
        }
        else
        {
            return c;
        }
    }
    else
    {
        if (b > c )
        {
            return b;
        }
        else
        {
            return c;
        }
    }
}

int MyWindow::bitsCoordFromXy(int x, int y)
{
    return 4 * (img_width * y + x);
}

int MyWindow::bitsCoordFromXy(int x, int y, int width)
{
    return 4 * (width * y + x);
}

void MyWindow::drawTriangle(Point a, Point b, Point c)
{
    uchar* outputBits = img->bits();

    int xMin = floor(min(a.x(), b.x(), c.x()));
    int yMin = floor(min(a.y(), b.y(), c.y()));
    int xMax =  ceil(max(a.x(), b.x(), c.x()));
    int yMax =  ceil(max(a.y(), b.y(), c.y()));

    for (int x = xMin; x <= xMax; ++x)
    {
        for (int y = yMin; y <= yMax; ++y)
        {
            // calculating input coordinates to source from through barycentrics
            double coeffs[3][2];
            for (int i = 0; i < 2; ++i)
            {
                double ai = a.coord(i);
                coeffs[0][i] = (i == 0 ? x : y) - ai;
                coeffs[1][i] = c.coord(i) - ai;
                coeffs[2][i] = b.coord(i) - ai;
            }
            double denominator = coeffs[2][0] * coeffs[1][1] - coeffs[1][0] * coeffs[2][1];
            double v = (coeffs[0][0] * coeffs[1][1] - coeffs[1][0] * coeffs[0][1]) / denominator;
            double w = (coeffs[2][0] * coeffs[0][1] - coeffs[0][0] * coeffs[2][1]) / denominator;
            double u = 1 - v - w;
            if (not (u < 0.0 or u > 1.0 or v < 0.0 or v > 1.0 or w < 0.0 or w > 1.0))
            {
                Point ia = brickTexture.point(0);
                Point ib = brickTexture.point(1);
                Point ic = brickTexture.point(2);

                Point inputCoords = ia * u + ib * v + ic * w;
                int floorX = floor(inputCoords.x());
                int floorY = floor(inputCoords.y());
                if (        areCoordsValid(inputCoords.x(), inputCoords.y())
                        and areCoordsValid(x,               y              ))
                {
                    // bilinear interpolation of color

                    int bitsCoords[2][2];
                    bitsCoords[0][0] = bitsCoordFromXy(floorX,     floorY    , 300);
                    bitsCoords[0][1] = bitsCoordFromXy(floorX + 1, floorY    , 300);
                    bitsCoords[1][0] = bitsCoordFromXy(floorX,     floorY + 1, 300);
                    bitsCoords[1][1] = bitsCoordFromXy(floorX + 1, floorY + 1, 300);

                    const uchar* inputBits = brickTexture.bits();

                    int outputBitsCoords = bitsCoordFromXy(x, y);

                    for (int component = 0; component < 3; ++component)
                    {
                        double neighbours[2][2];
                        for (int i = 0; i < 2; ++i)
                        {
                            for (int j = 0; j < 2; ++j)
                            {
                                neighbours[i][j] = inputBits[bitsCoords[i][j] + component];
                            }
                        }
                        double interpolated[2];
                        double factor = inputCoords.x() - floor(inputCoords.x());
                        for (int i = 0; i < 2; ++i)
                        {
                            interpolated[i] = (1 - factor) * neighbours[i][0] + factor * neighbours[i][1];
                        }
                        factor = inputCoords.y() - floor(inputCoords.y());
                        double finalInterpolated = (1 - factor) * interpolated[0] + factor * interpolated[1];
                        outputBits[outputBitsCoords + component] = round(finalInterpolated);
                    }
                }
            }
        }
    }
}

void MyWindow::updateProjection()
{
    img_clean();

    Matrix projectionMatrix;
    projectionMatrix = projectionMatrix * 300;
    projectionMatrix.set(0, 3, 300.0);
    projectionMatrix.set(1, 3, 300.0);
    projectionMatrix.set(2, 3, 300.0);

    double distance = 5.0;

    Matrix finalMatrix;
    finalMatrix = finalMatrix * translationMatrix;
    finalMatrix = finalMatrix * rotationMatrixXAxis;
    finalMatrix = finalMatrix * rotationMatrixYAxis;
    finalMatrix = finalMatrix * shearingXMatrix;
    finalMatrix = finalMatrix * shearingYMatrix;
    finalMatrix = finalMatrix * shearingZMatrix;
    finalMatrix = finalMatrix * scalingMatrix;

    for (auto polygon = polygons.begin(); polygon != polygons.end(); ++polygon)
    {
        Point points[3];
        for (int i = 0; i < 3; ++i)
        {
            points[i] = polygon->point(i);
            points[i] = finalMatrix * points[i];
            points[i].setX(points[i].x() * (distance / (points[i].z() + distance)));
            points[i].setY(points[i].y() * (distance / (points[i].z() + distance)));
            points[i] = projectionMatrix * points[i];
        }
        drawTriangle(points[0], points[1], points[2]);
    }

    update();
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{

    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    // Draws an image 'img' by copying it into the paint device.
    // (img_x0, img_y0) specifies the top-left point in the paint device that is to be drawn onto.
    p.drawImage(img_x0,img_y0,*img);
}


// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function (slot) called when the user clicks button "Draw 1" (draw1Button)
void MyWindow::on_draw1Button_clicked()
{
    update();
}

// Function (slot) called when the user clicks button "Draw 2" (draw2Button)
void MyWindow::on_draw2Button_clicked()
{
    update();
}

// Function cleaning the image (painting it in all white)
void MyWindow::img_clean()
{
    unsigned char *ptr;

    // 'bits()' returns a pointer to the first pixel of the image
    ptr = img->bits();

    int i,j;

    // i - current row, it changes from 0 to img_height-1
    for(i=0; i<img_height; i++)
    {
        // j - current column, it changes from 0 to img_width
        // each row has img_width pixels and 4 * img_width bytes (1 pixel = 4 bytes)
        for(j=0; j<img_width; j++)
        {
            // to obtain a white color we set each component on max value (255)
            ptr[img_width*4*i + 4*j]=255; // BLUE component
            ptr[img_width*4*i + 4*j + 1] = 255; // GREEN component
            ptr[img_width*4*i + 4*j + 2] = 255; // RED component
        }
    }
}

// Function (slot) called when the user press mouse button
void MyWindow::mousePressEvent(QMouseEvent *event)
{
    int x = event->x();
    int y = event->y();

    x -= img_x0;
    y -= img_y0;
}

void MyWindow::on_translationXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(0, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(1, 3, dvalue);
    updateProjection();
}

void MyWindow::on_translationZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    translationMatrix.set(2, 3, dvalue);
    updateProjection();
}

void MyWindow::on_rotationSlider1_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixXAxis.set(1, 1, cosine);
    rotationMatrixXAxis.set(1, 2, -sine);
    rotationMatrixXAxis.set(2, 1, sine);
    rotationMatrixXAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_rotationSlider2_valueChanged(int value)
{
    double angle = value / 1000.0 * 2 * M_PI;
    double sine = sin(angle);
    double cosine = cos(angle);
    rotationMatrixYAxis.set(0, 0, cosine);
    rotationMatrixYAxis.set(0, 2, sine);
    rotationMatrixYAxis.set(2, 0, -sine);
    rotationMatrixYAxis.set(2, 2, cosine);
    updateProjection();
}

void MyWindow::on_scalingXSlider_valueChanged(int value)
{
    double dvalue = value / 500.0;
    scalingMatrix.set(0, 0, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(1, 1, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingYSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingYSlider_valueChanged(int value)
{
    double dvalue = value / 500.0;
    scalingMatrix.set(1, 1, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(2, 2, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingZSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_scalingZSlider_valueChanged(int value)
{
    double dvalue = value / 500.0;
    scalingMatrix.set(2, 2, dvalue);
    if (scalingTogether)
    {
        scalingMatrix.set(0, 0, dvalue);
        scalingMatrix.set(1, 1, dvalue);
        ui->scalingXSlider->setValue(value);
        ui->scalingYSlider->setValue(value);
    }
    updateProjection();
}

void MyWindow::on_shearingXSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingXMatrix.set(0, 1, dvalue);
    shearingXMatrix.set(0, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingYSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingYMatrix.set(1, 0, dvalue);
    shearingYMatrix.set(1, 2, dvalue);
    updateProjection();
}

void MyWindow::on_shearingZSlider_valueChanged(int value)
{
    double dvalue = (value - 1000.0) / 500.0;
    shearingZMatrix.set(2, 0, dvalue);
    shearingZMatrix.set(2, 1, dvalue);
    updateProjection();
}

void MyWindow::on_resetButton_clicked()
{
    ui->translationXSlider->setValue(1000);
    ui->translationYSlider->setValue(1000);
    ui->translationZSlider->setValue(1000);
    ui->scalingXSlider->setValue(1000);
    ui->scalingYSlider->setValue(1000);
    ui->scalingZSlider->setValue(1000);
    ui->rotationSlider1->setValue(0);
    ui->rotationSlider2->setValue(0);
    ui->shearingXSlider->setValue(1000);
    ui->shearingYSlider->setValue(1000);
    ui->shearingZSlider->setValue(1000);
    updateProjection();
}

void MyWindow::on_scalingTogetherBox_toggled(bool checked)
{
    scalingTogether = checked;
}

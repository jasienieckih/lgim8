// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow)
{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    img_x0 = ui->drawFrame->x();
    img_y0 = ui->drawFrame->y();

    // Create an object of QImage class of appropriate width
    // and height. Set its format for 32-bit RGB (0xffRRGGBB).
    img = new QImage(img_width,img_height,QImage::Format_RGB32);

}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{

    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    // Draws an image 'img' by copying it into the paint device.
    // (img_x0, img_y0) specifies the top-left point in the paint device that is to be drawn onto.
    p.drawImage(img_x0,img_y0,*img);
}


// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function (slot) called when the user clicks button "Draw 1" (draw1Button)
void MyWindow::on_draw1Button_clicked()
{
    // Function 'img_draw1()' draws the pattern
    // definition is provided below
    img_draw1();
    update();
}

// Function (slot) called when the user clicks button "Draw 2" (draw2Button)
void MyWindow::on_draw2Button_clicked()
{
    // Function 'img_draw2()' draws the pattern
    // definition is provided below
    img_draw2();
    update();
}

// Function cleaning the image (painting it in all white)
void MyWindow::img_clean()
{
    unsigned char *ptr;

    // 'bits()' returns a pointer to the first pixel of the image
    ptr = img->bits();

    int i,j;

    // i - current row, it changes from 0 to img_height-1
    for(i=0; i<img_height; i++)
    {
        // j - current column, it changes from 0 to img_width
        // each row has img_width pixels and 4 * img_width bytes (1 pixel = 4 bytes)
        for(j=0; j<img_width; j++)
        {
            // to obtain a white color we set each component on max value (255)
            ptr[img_width*4*i + 4*j]= 0x00; // BLUE component
            ptr[img_width*4*i + 4*j + 1] = 0x00; // GREEN component
            ptr[img_width*4*i + 4*j + 2] = 0x00; // RED component
        }
    }
}


// Function drawing some pattern
void MyWindow::img_draw1()
{
        // removed
}

// Function drawing other pattern
void MyWindow::img_draw2()
{
        // removed
}

double mod(double d, double i)
{
    while (d >= i)
    {
        d -= i;
    }
    return d;
}

double abs(double x)
{
    return (x < 0) ? -x : x;
}

void MyWindow::updateColorSquare()
{
    uchar *bits = img->bits();

    for (int x = 0; x < 512; ++x)
    {
        for (int y = 0; y < 512; ++y)
        {
            int pixel = 4 * (512 * y + x);
            int red, green, blue;
            double hue, saturation, value;
            switch (colorMode)
            {
            case ColorMode::Red:
                red = sliderValueRgb;
                green = x / 2;
                blue = y / 2;
                break;
            case ColorMode::Green:
                green = sliderValueRgb;
                red = x / 2;
                blue = y / 2;
                break;
            case ColorMode::Blue:
                blue = sliderValueRgb;
                green = x / 2;
                red = y / 2;
                break;
            case ColorMode::Hue:
                hue = sliderValueHsv / 1000.0;
                saturation = x / 512.0;
                value = (511 - y) / 512.0;
                break;
            case ColorMode::Saturation:
                saturation = sliderValueHsv / 1000.0;
                hue = x / 512.0;
                value = (511 - y) / 512.0;
                break;
            case ColorMode::Value:
                value = sliderValueHsv / 1000.0;
                hue = x / 512.0;
                saturation = (511 - y) / 512.0;
                break;
            case ColorMode::NotSet:
                break;
            }

            if (colorMode == ColorMode::Hue
                    or colorMode == ColorMode::Saturation
                    or colorMode == ColorMode::Value)
            {
                double chroma = value * saturation;
                double hue_denormalized = hue * 6.0;
                double chroma_dual = chroma * (1.0 - abs(mod(hue_denormalized, 2.0) - 1.0));

                double rd, gd, bd;
                rd = gd = bd = 0.0;
                if (hue_denormalized < 1.0)
                {
                    rd = chroma;
                    gd = chroma_dual;
                }
                else if (hue_denormalized < 2.0)
                {
                    gd = chroma;
                    rd = chroma_dual;
                }
                else if (hue_denormalized < 3.0)
                {
                    gd = chroma;
                    bd = chroma_dual;
                }
                else if (hue_denormalized < 4.0)
                {
                    bd = chroma;
                    gd = chroma_dual;
                }
                else if (hue_denormalized < 5.0)
                {
                    bd = chroma;
                    rd = chroma_dual;
                }
                else
                {
                    rd = chroma;
                    bd = chroma_dual;
                }

                double vc_diff = value - chroma;
                rd += vc_diff;
                bd += vc_diff;
                gd += vc_diff;

                red = rd * 256;
                blue = bd * 256;
                green = gd * 256;
            }

            bits[pixel + 0] = blue;
            bits[pixel + 1] = green;
            bits[pixel + 2] = red;
        }
    }

    update();
}

// Function (slot) called when the user press mouse button
void MyWindow::mousePressEvent(QMouseEvent *event)
{
    // Get coordinates of the mouse cursor
    int x = event->x();
    int y = event->y();
    x = x * y;
}

void MyWindow::on_radioRed_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Red;
    updateColorSquare();
}

void MyWindow::on_radioGreen_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Green;
    updateColorSquare();
}

void MyWindow::on_radioBlue_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Blue;
    updateColorSquare();
}

void MyWindow::on_radioHue_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Hue;
    updateColorSquare();
}

void MyWindow::on_radioSaturation_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Saturation;
    updateColorSquare();
}

void MyWindow::on_radioValue_toggled(bool checked)
{
    if (checked) colorMode = ColorMode::Value;
    updateColorSquare();
}

void MyWindow::on_sliderRgb_valueChanged(int value)
{
    sliderValueRgb = value;
    updateColorSquare();
}

void MyWindow::on_sliderHSV_valueChanged(int value)
{
    sliderValueHsv = value;
    updateColorSquare();
}
